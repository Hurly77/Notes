## The problem with passwords

##### SessionsController#create

```ruby
def create
  @user = User.find_by(username: params[:username])
  return head(:forbidden) unless params[:password] == @user.password
  session[:user_id] = @user.id
end
```

This However is very insecure because, if we store passwords in the database then "hackers" could get their greed little mittens all over it which could be incredibly, dangerous to user's.

## Hashing passwords

However we can store password hashes. **Hash** *functions have the property that they will always produce the same number given the same input*

```ruby
# dumb_hash(input: string) -> number
def dumb_hash(input)
  input.bytes.reduce(:+)
end 
```

The `dumb_hash` function just finds the sum of the bytes the string.

Our `User` model and `SessionsController` might look like this:

```ruby
# app/models/user.rb
class User < ActiveRecord::Base
  def password=(new_password)
    self.password_digest = dumb_hash(new_password)
  end
 
  def authenticate(password)
    return nil unless dumb_hash(password) == password_digest
    self
  end
 
  private
 
  def dumb_hash(input)
    input.bytes.reduce(:+)
  end
end
 
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def create
    user = User.find_by(username: params[:username])
    authenticated = user.try(:authenticate, params[:password])
    return head(:forbidden) unless authenticated
    @user = user
    session[:user_id] = @user.id
  end
end
```

**Note:** [`try`](http://api.rubyonrails.org/classes/Object.html#method-i-try) is an ActiveSupport method. `object.try(:some_method)` means `if object != nil then object.some_method else nil end`.

We can use Bcrypt which is designed with these properties in mind:

1. BCrypt hashes similar strings to very different values.
2. It is a *cryptographic hash*. That means that, if you have an output in mind, finding a string which produces that output is designed to be "very difficult." "Very difficult" means "even if Google put all their computers on it, they couldn't do it."
3. BCrypt is designed to be slow — it is intentionally computationally expensive.

**The last two** features make BCrypt a particularly good choice for passwords.

## Salt

But what if our attackers have done their homework? The could use a ["rainbow table"](https://en.wikipedia.org/wiki/Rainbow_table). To make a hacker job even more difficult we could use **salt** 

A **salt - ** is a random string **prepended** to the password before hashing it.

Let's update our `User` model to use BCrypt:

```ruby
# Gemfile:
gem 'bcrypt'
 
# app/models/user.rb
class User < ActiveRecord::Base
  def password=(new_password)
    salt = BCrypt::Engine::generate_salt
    hashed = BCrypt::Engine::hash_secret(new_password, salt)
    self.password_digest = salt + hashed
  end
 
  # authenticate(password: string) -> User?
  def authenticate(password)
    # Salts generated by generate_salt are always 29 chars long.
    salt = password_digest[0..28]
    hashed = BCrypt::Engine::hash_secret(password, salt)
    return nil unless (salt + hashed) == self.password_digest
  end
end
```

Our `users.password_digest` column really stores two values: the salt and the actual return value of BCrypt. We just concatenate them together in the column and use our knowledge of the length of salts — `generate_salt` always produces 29-character strings — to separate them.

After we've loaded the User, we find the salt which we previously stored in their `password_digest` column. We run the password we were given in `params` through BCrypt along with the salt we read from the database. If the results match, you're in. If they don't, no dice.

## Rails makes it easier

`has_secure_password` that you can use on your ActiveRecord models to handle all this. It looks like this:

```ruby
class User < ActiveRecord::Base
  has_secure_password
end
```

[`has_secure_password`](http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html) adds two fields to your model: `password` and `password_confirmation`

`has_secure_password` also adds some `before_save` hooks to your model. These compare `password` and `password_confirmation`. If they match (or if `password_confirmation` is `nil`), then it updates the `password_digest` column pretty much exactly like our example code before did.

All together, our very secure app might look like this:

```erb
<%# app/views/user/new.html.erb %>
<%= form_for :user, url: '/users' do |f| %>
  Username: <%= f.text_field :username %>
  Password: <%= f.password_field :password %>
  Password Confirmation: <%= f.password_field :password_confirmation %>
  <%= f.submit "Submit" %>
<% end %>
```

```ruby
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def create
    User.create(user_params)
  end
 
  private
 
  def user_params
    params.require(:user).permit(:username, :password, :password_confirmation)
  end
end
```

```ruby
# app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  def create
    @user = User.find_by(username: params[:username])
    return head(:forbidden) unless @user.authenticate(params[:password])
    session[:user_id] = @user.id
  end
end
```

```ruby
# app/models/user.rb
class User < ActiveRecord::Base
  has_secure_password
end
```

## Video Review

- [Authentication](https://www.youtube.com/watch?v=gB7lYvfL4J4)

## Resources

- [Wikipedia — Murmur Hash](https://en.wikipedia.org/wiki/MurmurHash)
- [Wikipedia — Rainbow Table](https://en.wikipedia.org/wiki/Rainbow_table)
- [BCrypt USENIX paper](https://www.usenix.org/legacy/event/usenix99/provos/provos.pdf)
- [Rails documentation — `has_secure_password`](http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html)

View [Using `has_secure_password`](https://learn.co/lessons/has_secure_password_readme) on Learn.co and start learning to code for free.