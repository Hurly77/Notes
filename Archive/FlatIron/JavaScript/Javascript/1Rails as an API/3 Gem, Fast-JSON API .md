## Introduce the Fast JSON API

the [Fast JSON API](https://github.com/Netflix/fast_jsonapi) gem 

**The Fast JSON API** - is a JSON serializer for Rails APIs. It provides a way for us to generate *serializer* classes for each resource object in our API that is involved in customized JSON rendering. We can use these serializer classes to define the specific attributes we want objects to share or not share, along with things like related object attributes.

rather than writing a custom `render` each time, we write out a serializer for each object once and use Fast JSON API to control the way our data is structured.

## Initial Configuration

We will start at the same place we started when creating our own service class serializer.  

```ruby
#model
class Bird < ApplicationRecord
  has_many :sightings
  has_many :locations, through: :sightings
end

class Location < ApplicationRecord
  has_many :sightings
  has_many :birds, through: :sightings
end

class Location < ApplicationRecord
  has_many :sightings
  has_many :birds, through: :sightings
end
```

We also have one customized controller action:

```ruby
class SightingsController < ApplicationController
  def show
    sighting = Sighting.find_by(id: params[:id])
    render json: sighting.to_json(:include => {
      :bird => {:only => [:name, :species]},
      :location => {:only => [:latitude, :longitude]}
    }, :except => [:updated_at])
  end
end

# produces
{
  "id": 2,
  "bird_id": 2,
  "location_id": 2,
  "created_at": "2019-05-14T11:20:37.228Z",
  "bird": {
    "name": "Grackle",
    "species": "Quiscalus Quiscula"
  },
  "location": {
    "latitude": 30.26715,
    "longitude": -97.74306
  }
}
```

With just three objects and some minor customization, rendering has become complicated. With Fast JSON API, we can extract and separate this work into Serializer classes, keeping our controller cleaner.

## Setting up Fast JSON API

 add `gem 'fast_jsonapi'`

## Implementing the Fast JSON API

With, new `serializer` generator, we can create serializer classes for all three of our models

```ruby
rails g serializer Bird
rails g serializer Location
rails g serializer Sighting
```

we  get `serializers` folder within `/app`, and inside, `bird_serializer.rb`, `location_serializer.rb`, and `sighting_serializer.rb`. ****

## Updating the Controller Action

update our `render json:` statement so that it initializes the newly created `SightingSerializer`, passing in a variable, just as we did when creating our own service class:

```ruby
class SightingsController < ApplicationController
  def show
    sighting = Sighting.find(params[:id])
    render json: SightingSerializer.new(sighting)
  end
end
```

> **ASIDE**: Serializers generated by the **Fast** **JSON** **API** gem have two built-in methods called `serializable_hash` and `serialized_json` which return a serialized hash and a JSON string respectively. However, we don't actually need either of these in this example, as `to_json` will still be called on `SightingSerializer.new(sighting)` implicitly. As we will see, once our serializers are configured and initialized, we will not need
> to do any additional work

The `SightingSerializer.new(sighting)` statement can be used on *all* `SightingController` actions we want to serialize

```ruby
def index
  sightings = Sighting.all
  render json: SightingSerializer.new(sightings)
    #just pass in the array of all sightings as well:
end
```

But there is a problem still! 

```ruby
#server will only return
{
  "id": "2",
  "type": "sighting"
}
#The serializer is working, but it behaves a little differently than we're used to.
```

## Adding Attributes

**we must always specify what attributes we *want* to include.**

```ruby
class BirdSerializer
  include FastJsonapi::ObjectSerializer
  attributes :name, :species
end

_____________

class LocationSerializer
  include FastJsonapi::ObjectSerializer
  attributes :latitude, :longitude
end
___________

class SightingSerializer
  include FastJsonapi::ObjectSerializer
  attributes :created_at
end
_________
#If we go back and check http://localhost:3000/sightings/2 again
{
  "id": "2",
  "type": "sighting",
  "attributes": {
    "created_at": "2019-05-14T16:39:37.011Z"
  }
}
```

**use attributes to access related objects**

```ruby
class SightingSerializer
  include FastJsonapi::ObjectSerializer
  attributes :created_at, :bird, :location
end
```

This results in 

```ruby
#rendered JSON
{
  "id": "2",
  "type": "sighting",
  "attributes": {
    "created_at": "2019-05-14T16:39:37.011Z",
    "bird": {
      "id": 2,
      "name": "Grackle",
      "species": "Quiscalus Quiscula",
      "created_at": "2019-05-14T16:39:36.917Z",
      "updated_at": "2019-05-14T16:39:36.917Z"
    },
    "location": {
      "id": 2,
      "latitude": 30.26715,
      "longitude": -97.74306,
      "created_at": "2019-05-14T16:39:36.942Z",
      "updated_at": "2019-05-14T16:39:36.942Z"
    }
  }
}
```

However, here, we have no control over what attributes are included in the related objects, and so we get *all* the attributes

## Adding Relationships

**first step** is that we include the relationships we want to reflect in our serializers. **DO** this in the same way that we include them in the models themselves

```ruby
class SightingSerializer
  include FastJsonapi::ObjectSerializer
  attributes :created_at
  belongs_to :bird
  belongs_to :location
end

#but will only provide limited information, including the id of the related object:
{
  "id": "2",
  "type": "sighting",
  "attributes": {
    "created_at": "2019-05-14T16:39:37.011Z"
  },
  "relationships": {
    "bird": {
      "data": {
        "id": "2",
        "type": "bird"
      }
    },
    "location": {
      "data": {
        "id": "2",
        "type": "location"
      }
    }
  }
}
```

pass in a second *options* parameter to the serializer indicating that we want to *include* those objects:

```ruby
def show
  sighting = Sighting.find_by(id: params[:id])
  options = {
    include: [:bird, :location]
  }
  render json: SightingSerializer.new(sighting, options)
end
#The result:
{
  "data": {
    "id": "2",
    "type": "sighting",
    "attributes": {
      "created_at": "2019-05-14T16:39:37.011Z"
    },
    "relationships": {
      "bird": {
        "data": {
          "id": "2",
          "type": "bird"
        }
      },
      "location": {
        "data": {
          "id": "2",
          "type": "location"
        }
      }
    }
  },
  "included": [{
      "id": "2",
      "type": "bird",
      "attributes": {
        "name": "Grackle",
        "species": "Quiscalus Quiscula"
      }
    },
    {
      "id": "2",
      "type": "location",
      "attributes": {
        "latitude": 30.26715,
        "longitude": -97.74306
      }
    }
  ]
}
```

**Because** we have a `BirdSerializer` and a `LocationSerializer`, when including `:bird` and `:location`, Fast JSON API will automatically serialize their attributes as well.

## Not Quite the Data Structure We Started With

 we had the following JSON

```ruby
{
  "id": 2,
  "bird_id": 2,
  "location_id": 2,
  "created_at": "2019-05-14T11:20:37.228Z",
  "bird": {
    "name": "Grackle",
    "species": "Quiscalus Quiscula"
  },
  "location": {
    "latitude": 30.26715,
    "longitude": -97.74306
  }
}
```

**Using Fast JSON API**, with the use of relationships and passing a second parameter, **we** are able to get the **same *data***, but in a much **different structure**. **we could** fill out `Bird` and `Location` controllers and when we add in controller actions, we already have serializers created and ready to use!

**THOUGH**

>  In using **Fast JSON API** though, we lose the ability to design the structure of our JSON data.

 [documentation](https://github.com/Netflix/fast_jsonapi#table-of-contents) to become more familiar with it. It is possible, for instance, to create entirely custom attributes!